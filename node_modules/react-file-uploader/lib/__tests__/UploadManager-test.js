'use strict';

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _enzyme = require('enzyme');

var _enzymeAdapterReact = require('enzyme-adapter-react-16');

var _enzymeAdapterReact2 = _interopRequireDefault(_enzymeAdapterReact);

var _jsdom = require('jsdom');

var _nock = require('nock');

var _nock2 = _interopRequireDefault(_nock);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-undef, max-len */
jest.dontMock('../UploadManager');
jest.dontMock('../index');
jest.dontMock('classnames');
jest.dontMock('lodash');

var FileUploader = require('../index');
var UploadManager = FileUploader.UploadManager;
var uploadStatus = FileUploader.status;

(0, _enzyme.configure)({ adapter: new _enzymeAdapterReact2.default() });

describe('UploadManager', function () {
  var stringClass = 'receiver',
      arrayClass = ['react', 'receiver'],
      uploadPath = 'http://localhost:3000/api/upload',
      timeout = {
    response: 1000,
    deadline: 1000
  },
      children = _react2.default.createElement(
    'p',
    null,
    'children'
  ),
      uploadManager = void 0,
      onUploadAbort = void 0,
      onUploadStart = void 0,
      onUploadProgress = void 0,
      onUploadEnd = void 0,
      uploadDataHandler = void 0,
      uploadHeaderHandler = void 0,
      err = void 0,
      errorResponse = void 0,
      successResponse = void 0,
      errorHandler = void 0,
      file = void 0,
      fileCopy = void 0,
      customHeader = void 0;

  beforeEach(function () {
    global.document = (0, _jsdom.jsdom)();
    global.window = document.parentWindow;

    customHeader = {
      'Accept': 'customAccept',
      'Content-Type': 'customContentType',
      'Content-Disposition': 'customContentDisposition'
    };

    onUploadAbort = jest.genMockFn();
    onUploadStart = jest.genMockFn();
    onUploadProgress = jest.genMockFn();
    onUploadEnd = jest.genMockFn();
    uploadDataHandler = jest.genMockFn();
    uploadHeaderHandler = jest.genMockFn().mockReturnValue(customHeader);

    file = { id: 'fileId' };
    fileCopy = JSON.parse(JSON.stringify(file));

    err = new Error('not found');
    errorResponse = { body: { success: false, errors: { message: 'not found' } } };
    successResponse = { body: { success: true } };
    errorHandler = UploadManager.defaultProps.uploadErrorHandler;

    (0, _nock2.default)('http://localhost:3000').filteringRequestBody(function () {
      return '*';
    }).post('/api/upload', '*').reply(200, successResponse);

    uploadManager = (0, _enzyme.shallow)(_react2.default.createElement(
      UploadManager,
      {
        reqConfigs: {
          accept: 'application/json',
          method: 'post',
          timeout: timeout,
          withCredentials: true
        },
        customClass: stringClass,
        uploadUrl: uploadPath,
        onUploadAbort: onUploadAbort,
        onUploadStart: onUploadStart,
        onUploadProgress: onUploadProgress,
        onUploadEnd: onUploadEnd,
        uploadDataHandler: uploadDataHandler,
        uploadHeaderHandler: uploadHeaderHandler
      },
      children
    ));
  });

  afterEach(function () {
    _nock2.default.cleanAll();
    _nock2.default.enableNetConnect();
  });

  describe('render()', function () {
    it('should render ul element by default', function () {
      expect(uploadManager.type()).toEqual('ul');
      expect(uploadManager.childAt(0).type()).toEqual('p');
    });

    it('should render wrapper element according to component props', function () {
      uploadManager.setProps({ component: 'div' });
      expect(uploadManager.type()).toEqual('div');
    });

    it('should render a wrapper with customClass in string', function () {
      expect(uploadManager.hasClass(stringClass)).toBe(true);
    });

    it('should render a wrapper with customClass in array', function () {
      uploadManager.setProps({ customClass: arrayClass });

      arrayClass.forEach(function (classname) {
        expect(uploadManager.hasClass(classname)).toBe(true);
      });
    });
  });

  describe('uploadDataHandler()', function () {
    it('should return a FileData instance with a file data set', function () {
      var file = { data: 'fileData' },
          result = UploadManager.defaultProps.uploadDataHandler(file);
      expect(result).toBeInstanceOf(FormData);
      expect(result.get('file')).toEqual(file.data);
    });
  });

  describe('uploadErrorHandler()', function () {
    it('should return an object contains key of `error` and `result`', function () {
      var result = errorHandler(null, successResponse);
      expect(result.error).toBeNull();
      expect(result.result).toEqual(successResponse.body);
    });

    it('should return an object with key of `error` with value equals to the first argument if it is not empty', function () {
      var result = errorHandler(err, successResponse);
      expect(result.error).toEqual(err.message);
      expect(result.result).toEqual(successResponse.body);
    });

    it('should return an object with key of `error` with value equals to the value of `body.error` of the second argument if it is not empty', function () {
      var result = errorHandler(null, errorResponse);
      expect(result.error).toEqual(errorResponse.body.errors);
      delete errorResponse.body.errors;
      expect(result.result).toEqual(errorResponse.body);
    });
  });

  describe('uploadHeaderHandler()', function () {
    it('should return an empty object', function () {
      expect(UploadManager.defaultProps.uploadHeaderHandler()).toEqual({});
    });
  });

  describe('upload()', function () {
    it('should declare the request instance', function () {
      var instance = uploadManager.instance();
      instance.upload(instance.props.uploadUrl, file);

      var request = instance.requests[file.id];
      expect(request._timeout).toEqual(timeout);
      expect(request._header.accept).toEqual(customHeader['Accept']);
      expect(request._header['content-type']).toEqual(customHeader['Content-Type']);
      expect(request._header['content-disposition']).toEqual(customHeader['Content-Disposition']);
    });

    it('should call `props.onUploadStart` function if it is given', function () {
      var instance = uploadManager.instance();
      instance.upload(instance.props.uploadUrl, file);
      expect(onUploadStart).toBeCalledWith(file.id, { status: uploadStatus.UPLOADING });
      expect(file).toEqual(fileCopy);
    });

    it('should call `props.uploadDataHandler` function if it is given', function () {
      var instance = uploadManager.instance(),
          file = {};
      instance.upload(instance.props.uploadUrl, file);
      expect(uploadDataHandler).toBeCalledWith(file);
    });

    it('should call `props.uploadHeaderHandler` function if it is given', function () {
      var instance = uploadManager.instance(),
          file = {};
      instance.upload(instance.props.uploadUrl, file);
      expect(uploadHeaderHandler).toBeCalledWith(file);
    });
  });

  describe('abort()', function () {
    var instance = void 0,
        request = void 0;

    beforeEach(function () {
      instance = uploadManager.instance();
      instance.upload(instance.props.uploadUrl, file);
      request = instance.requests[file.id];
      request.abort = jest.genMockFn();
    });

    afterEach(function () {
      request.abort.mockClear();
    });

    it('should call `request.abort()` and `props.onUploadAbort()` if request instance is found.', function () {
      instance.abort();
      expect(request.abort).not.toBeCalled();

      instance.abort(file);
      expect(request.abort).toBeCalled();
      expect(onUploadAbort).toBeCalledWith(file.id, { status: uploadStatus.ABORTED });
    });
  });

  describe('onProgress()', function () {
    var instance = void 0,
        request = void 0,
        progress = 10;

    beforeEach(function () {
      instance = uploadManager.instance();
      instance.upload(instance.props.uploadUrl, file);
      request = instance.requests[file.id];
      request.aborted = false;
      request.xhr = {};
    });

    it('should call `props.onUploadProgress()` if request is not aborted', function (done) {
      instance.onProgress(file.id, progress);
      setTimeout(function () {
        expect(onUploadProgress).toBeCalledWith(file.id, { progress: progress, status: uploadStatus.UPLOADING });
        done();
      }, instance.props.progressDebounce);
    });
  });
});
/* eslint-enable no-undef, max-len */